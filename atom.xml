<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<title><![CDATA[ScarShow | 刀疤說]]></title>
	<subtitle>I know that I don't know</subtitle>
	<link href="http://scar.simcz.tw/atom.xml" rel="self" />
	<link href="http://scar.simcz.tw/" />
	<id>urn:uuid:2678fdc5-5c0a-82f6-3383-a3112866cd7f</id>
	<updated>2014-02-21T16:08:09+08:00</updated>
	<author>
		<name><![CDATA[ScarWu]]></name>
		<uri>http://scar.simcz.tw/</uri>
	</author>
	<entry>
		<title type="html"><![CDATA[Pointless所遭遇到的Segmentation Faults]]></title>
		<link href="http://scar.simcz.tw/article/2014/02/21/pointless-with-segmentation-faults" />
		<id>urn:uuid:7d40cfb8-50e2-e5eb-c0ae-02e69b0effae</id>
		<updated>2014-02-21T08:03:01+08:00</updated>
		<summary type="html"><![CDATA[<h2>怪事</h2>

<p>在開發<code>Pointless</code>到現在的兩年期間內，初期其實都還算順利，直到最近幾個月遇到了兩次<code>Segmentation Fault</code>，終於我遇的不是<code>PHP</code>的<code>Syntax Error</code>，而是<code>PHP</code>的<code>Bugs</code>或是其中函式庫的問題。</p>

<p>寫直譯式語言可以遇到語言的錯誤還滿猛的，一次是在<code>OS X</code>上用<code>PHPBrew</code>編出的<code>PHP</code>，另一次就是最近在<code>Ubuntu 13.10</code>及<code>Ubuntu 12.04 LTS</code>上還是用<code>PHPBrew</code>所編出的<code>PHP</code>。</p>

<p>題外話，話說<code>PHPBrew</code>超好用的，可以在不同版本的下作切換，對於開發來說實在是很棒。</p>

<!--more-->

<h2>在OS X的那次</h2>

<p>我先後在不同的兩台<code>Mac Air</code>測試過都會發生錯誤，在文章數量小的情況下不會有問題，但是文章只要一多就會發生錯誤。</p>

<p>而出錯的地方就是用來將資料及樣板結合的<code>bindData()</code>其中只有<code>include</code>以及<code>Output Buffer</code>等函式，但我檢查不出是<code>PHP VM</code>編譯時的哪支有問題所以作罷。</p>

<p>還因為這樣，當時還有人評論說這個部落格只要文章超過140字元就會爆炸。但這不是我的錯，這一定有誤會。</p>

<h2>在Ubuntu的這次</h2>

<p>最近，其實就是上禮拜，我再忙著把<code>Pointless</code>升級成支援<code>PHP 5.4</code>所以將系統中<code>PHP 5.4.12</code>升級到<code>PHP 5.4.25</code>以及<code>PHP 5.5.5</code>升級到<code>PHP 5.5.9</code>。</p>

<p>但是<code>PHP</code>在<code>./configure</code>的時候會出現<code>configure: error: Could not find libpcre.(a|so) in /usr</code>而失敗，把出現問題的檔案補上後，可以正常編譯了。</p>

<p>當我正開心要作測試的時候，他就爆了。這次的問題出現在剛剛的<code>PCRE Library</code>上，只要我在程式中使用<code>preg_match()</code>然後所輸入的字串太長就會爆炸。</p>

<p>所以我就重新編譯了新的<code>PCRE Library</code>，想當然爾<code>./configure</code>還是找不到檔案，手動補上檔案後在同樣的地方還是爆了...。最後我在另外一台機器上編譯同樣的檔案，使用同樣的<code>./configure</code>設定結果還是一樣。</p>

<h1>結論</h1>

<p><code>Mac OS X</code>系統預設的函式庫跟我正常使用的<code>Ubuntu</code>一定有哪邊不一樣。</p>

<p><code>Ubuntu</code>幾個月前的所使用的函式庫跟現在跟更新後的<code>Ubuntu</code>的函式庫一定有哪邊不一樣。</p>

<p>到底哪裡不一樣？我還要再查查。</p>
]]></summary>
	</entry>
	<entry>
		<title type="html"><![CDATA[Chrome - Enable Hardware Graphics]]></title>
		<link href="http://scar.simcz.tw/article/2014/01/19/chrome-enable-hardware-graphics" />
		<id>urn:uuid:a3b360b7-5d6e-9c12-8a64-7f83e97a6a7c</id>
		<updated>2014-01-19T12:48:58+08:00</updated>
		<summary type="html"><![CDATA[<h2>難得</h2>

<p>很難得可以在一天內發兩篇文章，在上一篇文末提到<code>WebGL</code>打不開的問題，那是個誤會，真的。</p>

<p>在<code>Chrome</code>的<code>chrome://flags</code>裡有一個選項<code>Override software rendering list</code>可以開啟硬體加速，在更新驅動程式前我怎樣試都不行，所以我就以為沒有用。</p>

<p>其實在驅動程式更新之後就已經可以使用了，只是硬體加速還要另外開啟，讓我產生<code>WebGL</code>無法開啟的錯覺。</p>

<!--more-->

<h2>正常啟用流程</h2>

<p>我們可以在<code>Chrome</code>中使用<code>chrome://gpu</code>這個連結去確認是否有開啟硬加速，在一般情況下都是呈現下方的狀態。</p>

<p><img src="/images/chrome-enable-hardware-graphics/gpu001.jpg" alt="Hardware Graphics"></p>

<p>更據上面所顯示的問題並去解決，就能開啟硬體加速，首先更據目前所用的作業統以及顯示卡，更新相對應的驅動程式。</p>

<p>在我的系統上，更新驅動程式後的狀態如下圖，原本紅紅一片的狀態逐漸變為正常了，<code>WebGL</code>也已經可以使用。</p>

<p><img src="/images/chrome-enable-hardware-graphics/gpu002.jpg" alt="Hardware Graphics"></p>

<p>最後將<code>chrome://flags</code>中的<code>Override software rendering list</code>啟動，並重新開啟<code>Chrome</code>。</p>

<p><img src="/images/chrome-enable-hardware-graphics/flags001.jpg" alt="Hardware Graphics"></p>

<p><img src="/images/chrome-enable-hardware-graphics/flags002.jpg" alt="Hardware Graphics"></p>

<p>最後就會得一片綠油油的正常狀態。</p>

<p><img src="/images/chrome-enable-hardware-graphics/gpu003.jpg" alt="Hardware Graphics"></p>

<h2>爽</h2>

<p>接下就爽爽用<code>Chrome</code>上的硬體加速吧。</p>
]]></summary>
	</entry>
	<entry>
		<title type="html"><![CDATA[Ubuntu 13.10 install AMD Catalyst 13.12]]></title>
		<link href="http://scar.simcz.tw/article/2014/01/19/ubuntu-13-10-install-amd-catalyst-13-12" />
		<id>urn:uuid:d2c45662-8551-28ca-e998-b7c95093c3e4</id>
		<updated>2014-01-19T10:30:55+08:00</updated>
		<summary type="html"><![CDATA[<h2>不解</h2>

<p>不知道為什麼，只要碰到顯示卡驅動程式的安裝，我就很容易讓我的機器爆炸，這一定有問題，所以還是趕快把這次成功安裝的過程記錄下來，避免之後又爆了。</p>

<p>安裝驅動有這麼難嗎？很難，因為每次都爆炸XD</p>

<p>平常我也不想去更新的我的顯示卡驅動，但是<code>Chrome</code>告訴我<code>ATI/AMD cards with older or third-party drivers</code>，我只是想開啟<code>WebGL</code>而已，為了能夠用<code>WebGL</code>還是更新吧。</p>

<!--more-->

<h2>安裝套件</h2>

<pre><code>sudo apt-get update &amp;&amp; sudo apt-get upgrade -y
sudo apt-get install cdbs dh-make dkms execstack dh-modaliases linux-headers-generic libqtgui4

# for x86_64 (64bit)
sudo apt-get install lib32gcc1
</code></pre>

<h2>下載 AMD Catalyst</h2>

<pre><code>mkdir amd-catalyst &amp;&amp; cd amd-catalyst
wget --referer='http://support.amd.com/en-us/download/desktop?os=Linux+x86' http://www2.ati.com/drivers/linux/amd-catalyst-13.12-linux-x86.x86_64.zip
unzip amd-catalyst-13.12-linux-x86.x86_64.zip
chmod +x amd-catalyst-13.12-linux-x86.x86_64.run
</code></pre>

<h2>編譯套件</h2>

<h3>Patch kcl_acpi.c</h3>

<pre><code>./amd-catalyst-13.12-linux-x86.x86_64.run --extract catalyst

cd catalyst
vim common/lib/modules/fglrx/build_mod/kcl_acpi.c
</code></pre>

<p>把<code>kcl_acpi.c</code>第990行以後的</p>

<pre><code class="c">#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(3,6,3)    
    if (!ACPI_SUCCESS(acpi_get_table_with_size(id, 0, &amp;hdr, &amp;tbl_size)))
#else
    tbl_size = 0x7fffffff;
    if (!ACPI_SUCCESS(acpi_get_table(id, 0, &amp;hdr)))
#endif
    {
        return KCL_ACPI_ERROR;
    }    
    ((acpi_table_handler)handler)(hdr);
    return KCL_ACPI_OK;
}
</code></pre>

<p>換成這個</p>

<pre><code class="c">#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(3,6,3)    
    if (!ACPI_SUCCESS(acpi_get_table_with_size(id, 0, &amp;hdr, &amp;tbl_size)))
#else
    tbl_size = 0x7fffffff;
    if (!ACPI_SUCCESS(acpi_get_table(id, 0, &amp;hdr)))
#endif
    {
        return KCL_ACPI_ERROR;
    }
#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(3,9,1)
    ((acpi_tbl_table_handler)handler)(hdr);
#else
    ((acpi_table_handler)handler)(hdr);
#endif
    return KCL_ACPI_OK;
}
</code></pre>

<h3>開始編譯</h3>

<pre><code>sudo ./ati-installer.sh 13.251 --buildpkg Ubuntu/saucy
</code></pre>

<h3>安裝 .deb 檔</h3>

<pre><code>cd ..
sudo dpkg -i fglrx*.deb
</code></pre>

<h2>設定環境</h2>

<h3>產生新的 xorg.conf</h3>

<pre><code>sudo amdconfig --initial -f
</code></pre>

<h3>選擇系統驅動程式</h3>

<pre><code># choice /usr/lib/fglrx/ld.so.conf
sudo update-alternatives --config x86_64-linux-gnu_gl_conf
sudo ldconfig
</code></pre>

<p>接下來就開心重新開機吧！</p>

<pre><code>sudo reboot
</code></pre>

<p>確認是否安裝成功可以用下面的指令做檢查</p>

<pre><code>fglrxinfo
fgl_glxgears
</code></pre>

<h3>更新失敗</h3>

<p>人生中難免會有風險，如果你重新開機後，發現螢幕上有國防布的話，那只好用以下方式修復</p>

<pre><code>sudo cp /etx/X11/xorg.conf.original /etc/X11/xorg.conf

# choice /usr/lib/x86_64-linux-gnu/mesa/ld.so.conf
sudo update-alternatives --config x86_64-linux-gnu_gl_conf
sudo ldconfig

sudo reboot
</code></pre>

<h2>最後</h2>

<p>更新驅動就花了我兩個早上，終於更新成功了，但是<code>Chrome</code>的<code>WebGL</code>還是不給開...</p>

<p>這一定有誤會。</p>

<h3>Reference</h3>

<ul>
<li><a href="http://support.amd.com/en-us/download" target="_blank">Download Driver - AMD Graphics Drivers and Software</a></li>
<li><a href="http://wiki.cchtml.com/index.php/Ubuntu_Saucy_Installation_Guide" target="_blank">Unoffical AMD Linux Community - Ubuntu Saucy Installation Guide</a></li>
<li><a href="https://gist.github.com/moldcraft/8116528" target="_blank">Install AMD Catalyst 13.12 Driver with patch on Ubuntu 13.10</a></li>
</ul>
]]></summary>
	</entry>
	<entry>
		<title type="html"><![CDATA[ZSH - history-search-backward/forward]]></title>
		<link href="http://scar.simcz.tw/article/2014/01/14/zsh-history-search-backward-and-forward" />
		<id>urn:uuid:c104f70b-f01c-0610-f999-ddf6e584f625</id>
		<updated>2014-01-14T08:50:49+08:00</updated>
		<summary type="html"><![CDATA[<p>原本<code>oh-my-zsh</code>在<code>Ubuntu 12.04 LTS</code>以及<code>Arch Linux</code>用好好的<code>history-search-backward</code>、<code>history-search-forward</code>，到了<code>Ubuntu 13.10</code>就不能用了，查了一下<code>ZSH</code>雖然版號不一樣，不知道是不是因為發行版影響，因為<code>Arch Linux</code>的<code>ZSH</code>版本還比<code>Ubuntu 13.10</code>新。</p>

<p>下面是各個發行版的<code>Z Shell</code>版號。</p>

<pre><code>Ubuntu 12.04 LTS : 4.3.17
Ubuntu 12.10     : 5.0.0
Ubuntu 13.04     : 5.0.0
Ubuntu 13.10     : 5.0.2
Arch Linux       : 5.0.5
</code></pre>

<!--more-->

<p>算了至少功能沒有那就自己加上去，在<code>~/.zshrc</code>中加入以下兩行就行了。</p>

<pre><code>bindkey "${key[Up]}" history-search-backward
bindkey "${key[Down]}" history-search-forward
</code></pre>

<p>接著重起<code>terminal</code>或是<code>source .zshrc</code>一切就完成了。</p>
]]></summary>
	</entry>
	<entry>
		<title type="html"><![CDATA[Express + Jade/LESS/Coffee with LiveReload]]></title>
		<link href="http://scar.simcz.tw/article/2014/01/03/express-jade-less-coffee-with-livereload" />
		<id>urn:uuid:e6b3a8b3-2368-4ead-4c48-8048c7cf69df</id>
		<updated>2014-01-03T11:23:52+08:00</updated>
		<summary type="html"><![CDATA[<h2>廢話</h2>

<p>2014年的第一篇文，去年算是生中的轉折，從今年開始已不是學生，但是學習不能停止，所以趁著比較有空的時候把TODO中要學的東西全部湊合在一起，混在一起當撒尿牛丸！</p>

<p>平常喜歡自幹習慣了，難得來用用別人已經做好的東西。這邊就先來用<code>Express</code>來搭配其它東西來開發網站。這邊用到的套件有<code>Jade</code>、<code>LESS</code>、<code>CoffeeScript</code>以及<code>LiveReload</code>。</p>

<!--more-->

<h3><a href="http://expressjs.com/" target="_blank">Express</a></h3>

<blockquote>
  <p>"web applicaion framework for node"</p>
</blockquote>

<p>可用於建立網站應用程式。是一套流行的<code>NodeJS</code>套件。</p>

<h3><a href="http://jade-lang.com/" target="_blank">Jade</a></h3>

<blockquote>
  <p>"Node Template Engine"</p>
</blockquote>

<p>擁有自己一套簡潔語法以及新的特性，用來產生HTML格式。</p>

<h3><a href="http://lesscss.org/" target="_blank">LESS</a></h3>

<blockquote>
  <p>"The dynamic stylesheet language"</p>
</blockquote>

<p>支援<code>Variable</code>、<code>Mixin</code>、<code>Nested Rule</code>...等，並可以編譯成<code>CSS</code>供瀏覽器使用。</p>

<h3><a href="http://coffeescript.org/" target="_blank">CoffeeScript</a></h3>

<blockquote>
  <p>"CoffeeScript is a little language that compiles into JavaScript"</p>
</blockquote>

<p>它將<code>JavaScript</code>的語法簡化，並提供一些新的特性來強化，可產生出符合規定且嚴謹的<code>JavaScript</code>程式碼。</p>

<p>它剛出來的時候超夯的，只是我一直都沒有去使用它。</p>

<h3><a href="http://livereload.com/" target="_blank">LiveReload</a></h3>

<blockquote>
  <p>"a happy land where browsers don't need a Refresh button"</p>
</blockquote>

<p>寫網頁最常做的事情就是不斷、不斷、不斷的Refresh頁面，它可以在檔案存檔的當下就自動幫你更新頁面，讓你可以即時看見更改後的結果。</p>

<p>它有很多的版本，這邊用到的是<code>NodeJS</code>的版本。</p>

<p><a href="https://github.com/napcs/node-livereload/" target="_blank">node-livereload</a></p>

<h2>產生並修改專案</h2>

<p><code>Express</code>本身預設的樣板引擎是<code>Jade</code>，另外內建就能支援<code>LESS</code>的middleware，在指令中加入參數<code>-c less</code>就可以了。</p>

<pre><code class="bash">express -c less /path/to/project
cd /path/to/project

vim .package.json
</code></pre>

<h3>package.json</h3>

<p>接著修改<code>package.json</code>，加入<code>connect-coffee-script</code>、<code>livereload</code>套件設定。</p>

<pre><code class="json">{
    "name": "application-name",
    "version": "0.0.1",
    "private": true,
    "scripts": {
        "start": "node app.js"
    },
    "dependencies": {
        "express": "3.4.7",
        "jade": "*",
        "less-middleware": "*"
        "connect-coffee-script": "*",
        "livereload": "*"
    }
}
</code></pre>

<p>最後就可以用<code>npm</code>安裝套件了。</p>

<pre><code class="bash">npm install
</code></pre>

<h3>app.js</h3>

<p>接下來開始修改<code>app.js</code>。</p>

<p>首先修改<code>LESS Middleware</code>的設定，將輸出<code>CSS</code>檔案的資料夾設定到<code>/tmp</code>，並且將壓縮設定開啟。</p>

<p>接著加入<code>CoffeeScript Middleware</code>的設定，同樣也是指定輸出資料夾為<code>/tmp</code>。最後將剛剛的輸出路徑<code>/tmp</code>加入到靜態檔案的路徑中。</p>

<p>將<code>Middleware</code>輸出檔案的路徑指定到<code>/tmp</code>有個好處，這樣設定<code>Git Ignore</code>就可以直接忽略掉這個資料夾，而且輸出的檔案也不會跟原始檔案混雜。</p>

<pre><code class="javascript">...

app.use(require('less-middleware') ({ 
    src: path.join(__dirname, 'public'),
    dest: path.join(__dirname, 'tmp'),
    compress: true
}));
app.use(require('connect-coffee-script') ({ 
    src: path.join(__dirname, 'public'),
    dest: path.join(__dirname, 'tmp')
}));

app.use(express.static(path.join(__dirname, 'public')));
app.use(express.static(path.join(__dirname, 'tmp')));

...
</code></pre>

<p>加入新的<code>Route rules</code>讓<code>LESS</code>及<code>CoffeeScript</code>的原始檔無法被讀取。</p>

<pre><code class="javascript">...

app.all('*.(coffee|less)', function (req, res) {
    res.send(404);
});
app.get('/', routes.index);
app.get('/users', user.list);

...
</code></pre>

<p>加入<code>LiveReload</code>的設定，讓它能夠認得<code>Jade</code>、<code>LESS</code>以及<code>CoffeeScript</code>的支援。
<code>Jade</code>是放在<code>/views</code>裡，而<code>LESS</code>、<code>CoffeeScript</code>則是放在<code>/public</code>裡，所以讓s<code>LiveReload</code>個別去監聽資料夾內檔案的變化。</p>

<pre><code class="javascript">...

var livereload = require('livereload').createServer({
    exts: ['jade', 'less', 'coffee']
});

livereload.watch(__dirname + '/public');
livereload.watch(__dirname + '/views');

...
</code></pre>

<p>最後別忘了幫瀏覽器安裝<code>LiveReload</code>的<code>extension</code>。</p>

<p><a href="http://feedback.livereload.com/knowledgebase/articles/86242-how-do-i-install-and-use-the-browser-extensions-)" target="_blank">LiveReload Extensions</a></p>

<h2>結語</h2>

<p>最後只要將<code>express</code>啟動，並將瀏覽器的<code>LiveReload Extension</code>連線打它就可以開始開發了。</p>

<p>下面是<code>app.js</code>完整的檔案。</p>

<pre><code class="javascript">var express = require('express');
var routes = require('./routes');
var user = require('./routes/user');
var http = require('http');
var path = require('path');

var app = express();

// all environments
app.set('port', process.env.PORT || 3000);
app.set('views', path.join(__dirname, 'views'));
app.set('view engine', 'jade');
app.use(express.favicon());
app.use(express.logger('dev'));
app.use(express.json());
app.use(express.urlencoded());
app.use(express.methodOverride());
app.use(app.router);

app.use(require('less-middleware') ({ 
    src: path.join(__dirname, 'public'),
    dest: path.join(__dirname, 'tmp'),
    compress: true
}));
app.use(require('connect-coffee-script') ({ 
    src: path.join(__dirname, 'public'),
    dest: path.join(__dirname, 'tmp')
}));

app.use(express.static(path.join(__dirname, 'public')));
app.use(express.static(path.join(__dirname, 'tmp')));

// development only
if ('development' == app.get('env')) {
  app.use(express.errorHandler());
}

app.all('*.(coffee|less)', function (req, res) {
    res.send(404);
});
app.get('/', routes.index);
app.get('/users', user.list);

http.createServer(app).listen(app.get('port'), function(){
  console.log('Express server listening on port ' + app.get('port'));
});

// LiveReload
var livereload = require('livereload').createServer({
    exts: ['jade', 'less', 'coffee']
});

livereload.watch(__dirname + '/public');
livereload.watch(__dirname + '/views');
</code></pre>
]]></summary>
	</entry>
</feed>