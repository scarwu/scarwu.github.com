<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<title><![CDATA[ScarShow | 刀疤說]]></title>
	<subtitle><![CDATA[< IS >]]></subtitle>
	<link href="https://scar.tw/atom.xml" rel="self" />
	<link href="https://scar.tw/" />
	<id>urn:uuid:4d418d05-9f8f-0741-8939-1476077aab63</id>
	<updated>2019-07-19T18:35:22+08:00</updated>
	<author>
		<name><![CDATA[ScarWu]]></name>
		<uri>https://scar.tw/</uri>
	</author>
	<entry>
		<title type="html"><![CDATA[每個人心中都有一套 RESTful API]]></title>
		<link href="https://scar.tw/article/2019/07/13/every-one-has-own-restful-api/" />
		<id>urn:uuid:d5f50dbf-d370-fc00-b1a1-ddd1e18b64ac</id>
		<updated>2019-07-19T18:35:11+08:00</updated>
		<summary type="html"><![CDATA[<p>當年還在念碩士的時候，不免俗的看了 Roy Fielding 的 <code>Representational State Transfer Architectural Style</code> 的論文。</p>
<p>而論文中所提到設計風格，則因為 Rails 所實作的 <code>RESTful API</code> 而發揚光大。</p>
<!--more-->
<h2>學習實作</h2>
<p>在查了許多關於如何實作的資料之後，發現除了論文中所提的設計風格重點之外，其中最常搭配的就是 <code>Rails</code> 的實作。</p>
<p>許多人會學習第一次學習實作 <code>RESTful API</code> 的第一個版本便是 Rails 的實作版本。</p>
<p>並且將它視為一個標準，當有另一個實作版本提出時某部分的細節不符合 Rails 的版本，便會遭到質疑。</p>
<h2>標準？原則！</h2>
<p>但要特別注意的是 <code>REST</code> 從來就不是標準，它也不像 <code>RPC</code> 及 <code>SOAP</code> 等有標準規範可以參考，也不會有任何一個實作是標準。</p>
<p>它僅是一個設計風格、是一個原則，只要設計出的 API 有達到 <code>REST</code> 其中所提到的約束，就能稱之為 RESTful API。</p>
<h2>REST-like</h2>
<p>雖然使用 REST 設計風格來實作 API 現在還是蔚為風潮，但是它並沒有辦法這麼簡單就能實作，大致上的困難點就有以下幾個。</p>
<p>所以有些大廠提供的 <code>API</code> 都會稱為 <code>REST-like</code>，它像是 <code>REST</code> 但不是 <code>REST</code>。</p>
<h3>HTTP Method 有限</h3>
<p>在目前最常用的就屬 <code>GET</code>、<code>POST</code>、<code>PUT</code> 及 <code>DELETE</code> 這四種 <code>Method</code> 最常用。</p>
<p>還有 <code>OPTIONS</code>、<code>HEAD</code> 及 <code>PATCH</code> 這三種 <code>Method</code> 還算是有用到。</p>
<p>最後是 <code>CONNECT</code> 及 <code>TRACE</code> 這兩種 <code>Method</code> 通常不會用到。</p>
<p>以上 9 種 <code>Method</code> 理論上實作不能超出這個限制，不然就會違反 <code>RFC</code> 的標準。</p>
<h3>前端語言支援度</h3>
<p>以前端的 JS 所提供的 <code>XMLHttpRequest</code> 來說僅支援六種 <code>Method</code> (<code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code>、<code>OPTIONS</code> 及 <code>HEAD</code>) 所以在實作上，如果是提供給前端所使用也無法超出此限制。</p>
<h3>後端語言支援度</h3>
<p>以後端語言 <code>PHP</code> 來說，雖然送任何的 <code>Mehotd</code> 它雖然都能接受，但僅有 <code>POST Method</code> 會預設對 <code>Request Body</code> 做處理 (<code>Content-Type</code> 為 <code>application/x-www-form-urlencoded</code> 及 <code>multipart/form-data</code>)，除此之外不管是要用 <code>application/json</code> 或是 <code>application/xml</code>都必須要自行處理，但基本上影響不大。</p>
<h3>設計與實作複雜度</h3>
<p>最後以設計與實作面來說，例如 <code>使用者忘記密碼重新設定</code> 的功能如果要設計及實作的話，很可能就會超出了限制範圍，雖然都是對 <code>/user</code> 這個資源操作，但很有可能你所需要的操作不符合 <code>Verb</code> 或是 <code>URI</code>。</p>
<p>以上，一點點的淺見。</p>
<h2>References</h2>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods">https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods</a></li>
<li><a href="https://en.wikipedia.org/wiki/XMLHttpRequest">https://en.wikipedia.org/wiki/XMLHttpRequest</a></li>
<li><a href="https://scar.tw/article/2012/08/19/hack-php-to-support-put-fileupload/">https://scar.tw/article/2012/08/19/hack-php-to-support-put-fileupload/</a></li>
</ul>
<!--
在2011 2000論文 弔詭的是實作 Rails 將 REST 發揚光大，但
拿 rails 的實作你可以參考但不能視為一個標準是不合邏輯的
除非明訂有標準可循 IEEE RFC WSDL SOAP RPC
符合設計原則
設計風格不是標準
HTTP Status Code 有限 rfc 標準
瀏覽器支援度
後端語言支援度
實作複雜度
每個人實作都有能會有一些差異 只要符合設計原則都能稱之為
但事實上不好實作所以大部分一些大廠 API都只會表明說是 RESTful-like
淺見
-->]]></summary>
	</entry>
	<entry>
		<title type="html"><![CDATA[用 Redis 簡單粗暴實作 MQ]]></title>
		<link href="https://scar.tw/article/2019/05/29/using-redis-implement-mq/" />
		<id>urn:uuid:865669d5-3e0a-1f74-54fa-fddf72d77b0f</id>
		<updated>2019-05-29T12:57:24+08:00</updated>
		<summary type="html"><![CDATA[<p>話先說在前頭 <code>Redis</code> 是快取伺服器不是 <code>Message Queue</code>，但有時候現實面不允許時還是必須要妥協。</p>
<p>先用 <code>Redis</code> 將功能實作出來，往後再找適合的 <code>MQ</code> 產品去替換 <code>Redis</code>。</p>
<!--more-->
<h2>簡單說明</h2>
<p><code>Redis</code> 是一個分散式且支援持久化的 <code>key-value</code> 快取伺服器，除了單純 <code>Get/Set</code> 操作變數之外還提供許多額外的函數用來操作變數。</p>
<h2>運作原理</h2>
<p>上面說到了除了單純的 <code>Get/Set</code> 之外，能夠實作 <code>MQ</code> 的關鍵就在於而外提供的函數，主要能夠實作出 <code>MQ</code> 的關鍵在於 <code>Push/Pop</code> 的函數。</p>
<p>這組函數主要是將變數作為 List 處理，可以將它模擬成 <code>Queue</code> 或是 <code>Stack</code>，現在我們是要將它實作成 <code>MQ</code> 所以我們要模擬成 <code>Queue</code>。</p>
<p>我們可以使用函數 <code>lPush, brPop</code> 或是 <code>rPush, blPop</code> 實作，要注意的是我們在 <code>Pop</code> 的時候使用 <code>Blocking</code> 模式的函數，可以設定 <code>Connection Timeout</code> 用來減少伺服器壓力。</p>
<h2>Sample Code</h2>
<p>下面是簡單的程式範例。</p>
<h3>Producer</h3>
<pre><code>&lt;?php
$redis = (new Redis)-&gt;connect('127.0.0.1', 6379);

// Enqueue
$json = json_encode([
    'timestamp' =&gt; time()
]);
$redis-&gt;lPush('mq', $json);</code></pre>
<h3>Consumer</h3>
<pre><code>&lt;?php
$redis = (new Redis)-&gt;connect('127.0.0.1', 6379);

// Dequeue
$bundle = $redis-&gt;brPop('mq', 60);
$json = json_decode($bundle[1], true);

var_dump($json);</code></pre>
<h2>Reference</h2>
<ul>
<li><a href="https://zh.wikipedia.org/zh-tw/Redis">Redis - Wiki</a></li>
<li><a href="https://github.com/phpredis/phpredis">PHP Redis</a></li>
</ul>]]></summary>
	</entry>
	<entry>
		<title type="html"><![CDATA[使用 PHP OPCache 的正確姿勢]]></title>
		<link href="https://scar.tw/article/2019/05/29/php-opcache-tuning/" />
		<id>urn:uuid:a5d92b8a-eea9-b360-9dab-1ee83a3d17d2</id>
		<updated>2019-05-29T11:40:17+08:00</updated>
		<summary type="html"><![CDATA[<p><code>PHP OPCache</code> 看起來很迷人，但有時會被它傷得滿身，有可能今早用起來好好的系統，下午就突然壞掉了。</p>
<p>人在江湖飄，哪能不挨刀？某天我就挨了好幾刀。</p>
<!--more-->
<h2>Trouble</h2>
<p>基本上在生產環境開啟它是正確的選擇，對於效能上增進還是很不錯的，但凡事都有意外...例如無法強制清除快取。</p>
<p>問題是這樣子的，在某次部署之後，強制清除快取卻異常失效，快取的檔案版本不一致，導致網站異常。</p>
<p>所以又去看了原本的設定並且做了一且調整。</p>
<h2>Config</h2>
<p>下面是所有的設定，但有些設定還是要注意一下。</p>
<p>設定要注意一下，<code>opcache.validate_timestamps</code> 在開啟的時候 <code>opcache.revalidate_freq</code> 的時間檢查才會發揮作業。</p>
<p>但在生產環境上是推薦將 <code>opcache.validate_timestamps</code> 關閉，然後在部署成功之後再清除快取。</p>
<p>但因為有發生過無法強制清除快取的事件，所以在這邊折衷將 <code>opcache.validate_timestamps</code> 開啟讓 <code>Opcache</code> 去自動檢查並清除快取。</p>
<pre><code>[opcache]
;opcache.enable=0
;opcache.enable_cli=0
;opcache.memory_consumption=64
;opcache.interned_strings_buffer=4
;opcache.max_accelerated_files=2000
;opcache.max_wasted_percentage=5
;opcache.use_cwd=1
;opcache.validate_timestamps=1
;opcache.revalidate_freq=2
;opcache.revalidate_path=0
;opcache.save_comments=1
;opcache.load_comments=1
;opcache.fast_shutdown=1
;opcache.enable_file_override=0
;opcache.optimization_level=0xffffffff
;opcache.inherited_hack=1
;opcache.dups_fix=0
;opcache.blacklist_filename=
;opcache.max_file_size=0
;opcache.consistency_checks=0
;opcache.force_restart_timeout=180
;opcache.error_log=
;opcache.log_verbosity_level=1
;opcache.preferred_memory_model=
;opcache.protect_memory=0</code></pre>
<p>以下針對此次問題所調整的設定。</p>
<pre><code>opcache.validate_timestamps=1
opcache.revalidate_freq=60</code></pre>
<h2>Clean Cache</h2>
<p>清除快取的方式，必須在正確的行程中執行指令或是將行程重新啟動才能清除。</p>
<p>所以這邊要注意的是在 <code>CLI</code> 執行 <code>opcache_reset()</code> 是無法影響到 <code>php-fpm</code> 的。</p>
<pre><code class="language-php">&lt;?php
opcache_reset();</code></pre>
<pre><code class="language-bash">service php-fpm reload</code></pre>
<h2>Reference</h2>
<ul>
<li><a href="https://php.net/manual/en/opcache.configuration.php">Opcache Runtime Configuration</a></li>
<li><a href="https://ma.ttias.be/how-to-clear-php-opcache/">How To Clear PHP’s Opcache</a></li>
<li><a href="https://gywbd.github.io/posts/2016/1/best-config-for-zend-opcache.html">zend opcache的最佳设置</a></li>
</ul>]]></summary>
	</entry>
	<entry>
		<title type="html"><![CDATA[Nginx + Lua with Alpine Linux]]></title>
		<link href="https://scar.tw/article/2019/05/28/nginx-lua-with-alpine-linux/" />
		<id>urn:uuid:46cde755-2df6-a88c-f1a0-d9935edfa500</id>
		<updated>2019-06-20T14:42:57+08:00</updated>
		<summary type="html"><![CDATA[<p>最近在升級公司服務，在原有的環境是使用 <code>Ubuntu</code> + <code>Nginx Extras</code>，但為了最小化容器尺寸所以使用了 <code>Alpine Linux</code>，原本想說能順利轉換，但事情絕對不會是憨人想得這麼簡單。</p>
<p>雖然 <code>Alpine</code> 的 <code>Nginx</code> 有把 <code>Lua Module</code> 編進去，但是 <code>Nginx</code> 在運行時會缺少新版的 <code>Openresty LuaJIT</code> 核心導致無法運行，且在套件庫中的 <code>LuaJIT</code> 只有舊版，原本嘗試自行編譯但遇到了一些問題繞了些路，最終解決方法卻異常簡單。</p>
<!--more-->
<h2>Code</h2>
<h3>Dockerfile</h3>
<p>解決 <code>Openresty LuaJIT</code> 核心的問題，原本也是要連同 <code>Nignx</code> 一起自行編譯的。</p>
<p>最後直接使用 <code>Openresty</code> 官方的 <code>Alpine Linux</code> 然後再把 <code>Nginx</code> 跟 <code>Lua Module</code> 直接安裝進去就完成了。</p>
<pre><code class="language-dockerfile">FROM openresty/openresty:alpine

RUN apk --update add \
    nginx \
    nginx-mod-http-lua \
    nginx-mod-http-lua-upstream

...</code></pre>
<h3>Nginx Config</h3>
<p>接著在 <code>Nginx</code> 的設定檔中加入最重要的一段設定載入動態套件庫以及 <code>Lua Lib</code> 的路徑到 <code>OpenResty</code>。</p>
<pre><code class="language-conf">user nginx nginx;

include /etc/nginx/modules/*.conf;

...

http {
    lua_package_path "/usr/local/openresty/lualib/?.lua;;";
    lua_package_cpath "/usr/local/openresty/lualib/?.so;;";

    ...
}</code></pre>
<h2>Done</h2>
<p>這樣 <code>Alpine Linux</code> 的 <code>Nginx</code> 就可以支援 <code>Lua</code>，而不用回頭用 <code>Ubuntu</code> 的解決方案了。</p>]]></summary>
	</entry>
	<entry>
		<title type="html"><![CDATA[良好的專案檔案編排]]></title>
		<link href="https://scar.tw/article/2019/02/13/good-file-structure-for-project/" />
		<id>urn:uuid:50088711-0cfe-90d0-3af9-54a320877538</id>
		<updated>2019-02-13T02:21:04+08:00</updated>
		<summary type="html"><![CDATA[<p>在看過各種語言以及各種專案之後，對於專案資料夾結構的編排有了一些想法，可能對於一些人來說覺得意義不大，將檔案整齊排放是個好習慣。</p>
<p>良好的結構讓檔案一目了然有助於開發，你可能會說習慣成自然，專案通常不會只有一個人開發也會有交接的問題，養成好習慣把結構整理乾淨。</p>
<p>一般框架或工具的官方文件，亦或者是使用 CLI 工具所產生出來的專案，通常都會有既定的結構存在，通常我在開發時不會照單全收，通常還會再進一步修改。</p>
<!--more-->
<h2>編排</h2>
<p>基本上資料夾的結構編排，通常是遵循一個大方向將檔案擺放整齊，以一般網站開發的專案來說通常會有以下幾種類型的檔案：</p>
<ol>
<li>原始碼
<ul>
<li>專案本身的程式碼</li>
</ul></li>
<li>說明文件
<ul>
<li>程式碼說明、應用程式接口或是第三方套件的說明文件</li>
</ul></li>
<li>測試文件
<ul>
<li>程式碼本身的測試</li>
</ul></li>
<li>第三方套件與設定
<ul>
<li>可能來自 <code>npm</code>、<code>bower</code>、<code>composer</code> 或是 <code>gem</code> 的設定文件以及安裝目標的資料夾</li>
</ul></li>
<li>CI/CD 設定
<ul>
<li>持續整合、交付或是部署的設定檔</li>
</ul></li>
<li>Module Bundler
<ul>
<li>像是 <code>webpack</code> 或是 <code>bowserify</code> 之類的工具</li>
</ul></li>
<li>Task Runner
<ul>
<li>輔助開發的行程工具例如 <code>gulp</code> 或 <code>grunt</code></li>
</ul></li>
<li>輸出檔
<ul>
<li>編譯好的檔案，或是可用作部署的檔案</li>
</ul></li>
<li>暫存檔
<ul>
<li>一些開發過程中會產生的暫時性檔案</li>
</ul></li>
<li>其它
<ul>
<li>根據開發不同可能會用到的其它檔案</li>
</ul></li>
</ol>
<h3>檔案</h3>
<p>大致上的編排方法是將 <code>第三方套件設定</code>、<code>CI/CD 設定</code>、<code>Module Bundler</code> 及 <code>Task Runner</code>，這類的檔案放置在專案的根目錄中，主要原因為：</p>
<ol>
<li>這類的檔案通常關乎到專案本身的設定</li>
<li>輔助開發的工具通常是將設定放置於此</li>
</ol>
<h3>資料夾</h3>
<p>接下來是將 <code>原始碼</code>、<code>說明文件</code>、<code>測試程文件</code>、<code>輸出檔</code> 及 <code>暫存檔</code> 分別獨立出一個資料夾個別存放該檔案。</p>
<p>這幾類的檔案占了專案大部分，每種類型的檔案用途都非常明確，所以獨立存放會是個好選擇也方便管理。</p>
<h2>命名</h2>
<p>上面說到了擺放的原則，那接下來資料夾的命名也是很重要，除了放置在專案根目錄有既有名稱之外的資料夾基本上都是自由命名，但就跟寫程式一樣參數及函式的命名一樣要淺顯易懂。</p>
<p>所以通常我會這樣命名：</p>
<ol>
<li>原始碼
<ul>
<li>通常會使用 <code>src</code> 或是 <code>source</code>，我使用前者居多。如果是程式碼本身結構所使用的資料夾，一般參考框架本身的建議</li>
</ul></li>
<li>說明文件
<ul>
<li>一般使用 <code>docs</code> 要寫 <code>manual</code> 也行，內部名稱結構依據閱讀方式自行規劃</li>
</ul></li>
<li>測試文件
<ul>
<li>就使用 <code>tests</code> 了，內部資料夾一樣也是根據工具的規範</li>
</ul></li>
<li>輸出檔
<ul>
<li>這邊可以是 <code>release</code>、<code>dist</code> 或是 <code>output</code>，如果最後編出的是指令的話可以使用 <code>bin</code></li>
</ul></li>
<li>暫存檔
<ul>
<li><code>tmp</code> 或是 <code>temp</code></li>
</ul></li>
</ol>
<h2>好處</h2>
<p>對於個人或是團隊的助益有以下幾點：</p>
<ol>
<li>降低閱讀門檻</li>
<li>利用開發</li>
<li>易於管理</li>
<li>潔癖覺得舒服</li>
<li>也是重構的其中一環</li>
</ol>]]></summary>
	</entry>
</feed>